<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Algoritmos Evolutivos</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f0f2f5;
      color: #333;
    }
    header {
      background-color: #004d99;
      color: white;
      padding: 20px;
      text-align: center;
    }
    section {
      padding: 20px;
      max-width: 1000px;
      margin: auto;
    }
    h2 {
      color: #004d99;
    }
    .card {
      background-color: white;
      border-radius: 10px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    pre {
      background: #272822;
      color: #f8f8f2;
      padding: 15px;
      border-radius: 10px;
      overflow-x: auto;
      font-size: 14px;
    }
    ul {
      margin-top: 10px;
    }
    li {
      margin-bottom: 8px;
    }
    footer {
      text-align: center;
      padding: 10px;
      background-color: #ddd;
    }
  </style>
</head>
<body>
  <header>
    <h1>Algoritmos de Evolutivos</h1>
    <p>Hill Climbing y Algoritmos Gen茅ticos Evolutivos</p>
  </header>

  <section>
    <div class="card">
      <h2>1. 驴Qu茅 es Hill Climbing?</h2>
      <p>Hill Climbing es un algoritmo de b煤squeda heur铆stica utilizado para encontrar una soluci贸n 贸ptima al ir mejorando iterativamente una soluci贸n inicial. Se mueve hacia una mejor soluci贸n siempre que sea posible, es decir, solo acepta cambios que mejoran el resultado. Es 煤til en problemas de optimizaci贸n donde se desea maximizar o minimizar una funci贸n objetivo.</p>

      <h3>锔 Caracter铆sticas clave:</h3>
      <ul>
        <li>Es un algoritmo <strong>greedy</strong>: siempre avanza hacia soluciones que mejoran la actual.</li>
        <li>R谩pido y simple, pero puede quedarse atrapado en 贸ptimos locales.</li>
        <li>Es 煤til cuando se desconoce la estructura global del problema.</li>
      </ul>

      <h3>Л Variantes:</h3>
      <ul>
        <li><strong>Hill Climbing Simple</strong>: analiza una vecina aleatoria por iteraci贸n.</li>
        <li><strong>Steepest-Ascent Hill Climbing</strong>: eval煤a todos los vecinos posibles y elige el mejor.</li>
        <li><strong>Hill Climbing con reinicios aleatorios</strong>: se ejecuta m煤ltiples veces desde puntos distintos para evitar 贸ptimos locales.</li>
      </ul>
    </div>

    <div class="card">
      <h2>2. 驴Qu茅 son los Algoritmos Gen茅ticos Evolutivos?</h2>
      <p>Los algoritmos gen茅ticos son m茅todos de b煤squeda y optimizaci贸n inspirados en la evoluci贸n biol贸gica. Utilizan operadores como selecci贸n, cruce (crossover) y mutaci贸n para evolucionar una poblaci贸n de posibles soluciones hacia mejores resultados. Se basan en principios de la gen茅tica natural y son efectivos para resolver problemas complejos donde otras t茅cnicas pueden fallar.</p>

      <h3> Proceso general:</h3>
      <ul>
        <li><strong>Inicializaci贸n</strong>: se crea una poblaci贸n inicial de soluciones (individuos).</li>
        <li><strong>Evaluaci贸n</strong>: se mide el rendimiento (fitness) de cada individuo.</li>
        <li><strong>Selecci贸n</strong>: se eligen los individuos m谩s aptos.</li>
        <li><strong>Cruce (crossover)</strong>: se combinan dos individuos para generar descendencia.</li>
        <li><strong>Mutaci贸n</strong>: se hacen peque帽os cambios aleatorios para mantener la diversidad.</li>
        <li><strong>Reemplazo</strong>: la nueva generaci贸n sustituye a la anterior.</li>
      </ul>

      <h3>К Aplicaciones:</h3>
      <ul>
        <li>Optimizaci贸n de rutas.</li>
        <li>Dise帽o de redes neuronales.</li>
        <li>Problemas combinatorios.</li>
        <li>Ajuste de par谩metros en modelos complejos.</li>
      </ul>
    </div>

    <div class="card">
      <h2>3. Implementaci贸n en Python</h2>
      <p>A continuaci贸n, se presentan ejemplos b谩sicos de implementaci贸n de ambos algoritmos en Python para la funci贸n <code>f(x) = -x虏 + 10x</code>:</p>

      <h3> Hill Climbing</h3>
      <pre><code>import random

def funcion_objetivo(x):
    return -x**2 + 10*x

def hill_climbing():
    x = random.uniform(0, 10)
    paso = 0.1
    max_iter = 100

    for _ in range(max_iter):
        vecino = x + random.choice([-paso, paso])
        if 0 <= vecino <= 10 and funcion_objetivo(vecino) > funcion_objetivo(x):
            x = vecino

    return x, funcion_objetivo(x)

mejor_x, mejor_valor = hill_climbing()
print(f"Mejor x: {mejor_x:.4f} con valor: {mejor_valor:.4f}")</code></pre>

      <h3>К Algoritmo Gen茅tico</h3>
      <pre><code>import random

def funcion_objetivo(x):
    return -x**2 + 10*x

def crear_individuo():
    return random.uniform(0, 10)

def mutar(x, tasa=0.1):
    return x + random.uniform(-tasa, tasa)

def cruzar(padre1, padre2):
    return (padre1 + padre2) / 2

def algoritmo_genetico(poblacion_size=10, generaciones=20):
    poblacion = [crear_individuo() for _ in range(poblacion_size)]

    for _ in range(generaciones):
        poblacion = sorted(poblacion, key=funcion_objetivo, reverse=True)
        nueva_poblacion = poblacion[:2]

        while len(nueva_poblacion) < poblacion_size:
            padre1, padre2 = random.sample(poblacion[:5], 2)
            hijo = cruzar(padre1, padre2)
            hijo = mutar(hijo)
            hijo = max(0, min(10, hijo))
            nueva_poblacion.append(hijo)

        poblacion = nueva_poblacion

    mejor = max(poblacion, key=funcion_objetivo)
    return mejor, funcion_objetivo(mejor)

mejor_x, mejor_valor = algoritmo_genetico()
print(f"Mejor x: {mejor_x:.4f} con valor: {mejor_valor:.4f}")</code></pre>
    </div>
  </section>

  <footer>
    <p>Proyecto Agentes Evolutivos - S4</p>
  </footer>
</body>
</html>
